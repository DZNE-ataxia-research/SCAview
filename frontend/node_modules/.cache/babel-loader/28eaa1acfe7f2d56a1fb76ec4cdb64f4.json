{"ast":null,"code":"import localStorage from '../services/LocalStorage';\nimport utilities from '../services/Utilities';\nimport _axios from 'axios';\nlet token;\n\nconst axios = _axios.create({\n  withCredentials: true\n}); // HELPER\n\n\nconst parseFigure = input => {\n  var _figure$data;\n\n  const figure = JSON.parse(input);\n  return { ...figure,\n    data: (_figure$data = figure.data) === null || _figure$data === void 0 ? void 0 : _figure$data.map(fd => {\n      return { ...fd,\n        // use scatter plot WebGL variant to improve performance\n        type: fd.type === 'scatter' ? 'scattergl' : fd.type\n      };\n    })\n  };\n}; // SESSION INIT\n\n\n// @TODO define SessionInitReturn\nconst sessionInit = (identifiers = []) => {\n  const requestBody = {\n    usertoken: token,\n    plot_ids: identifiers\n  };\n  return axios.post(`${api_url}/init`, requestBody).then(response => response.data);\n}; // SESSION RESET\n\n\n// @TODO define SessionResetReturn\nconst sessionReset = () => {\n  const requestBody = {\n    usertoken: token\n  };\n  return axios.post(`${api_url}/reset-session`, requestBody).then(response => response.data);\n}; // CONTROLS UPDATE\n\n\nexport let Legend;\n\n(function (Legend) {\n  Legend[\"none\"] = \"none\";\n  Legend[\"legend\"] = \"legend\";\n})(Legend || (Legend = {}));\n\nexport let Fit;\n\n(function (Fit) {\n  Fit[\"none\"] = \"none\";\n  Fit[\"regression\"] = \"regression\";\n})(Fit || (Fit = {}));\n\nvar Stack;\n\n(function (Stack) {\n  Stack[\"stack\"] = \"stack\";\n})(Stack || (Stack = {}));\n\nvar Norm;\n\n(function (Norm) {\n  Norm[\"norm\"] = \"norm\";\n})(Norm || (Norm = {}));\n\nconst controlsUpdate = controlsState => {\n  const requestBody = {\n    usertoken: token,\n    controls: {\n      plot: controlsState.identifier,\n      type: controlsState.type,\n      attX: controlsState.attX,\n      attY: controlsState.attY,\n      attC: controlsState.attC,\n      Dt: controlsState.dt,\n      visit: controlsState.visit,\n      followup: controlsState.followup,\n      tolerance: controlsState.tolerance,\n      bins: controlsState.bins,\n      norm: controlsState.norm ? [Norm.norm] : [],\n      stack: controlsState.stack ? [Stack.stack] : [],\n      fit: [controlsState.fit],\n      legend: [controlsState.legend]\n    }\n  };\n  return axios.post(`${api_url}/getdata`, requestBody).then(responseRaw => {\n    return parseFigure(responseRaw.data.figure);\n  });\n}; // FILTER UPDATE\n\n\nconst filterUpdate = filterState => {\n  const requestBody = {\n    usertoken: token,\n    concept: filterState.concept,\n    filter_table: filterState.constraints.map(constraint => {\n      return {\n        attribute: constraint.attribute,\n        lower: constraint.lower,\n        upper: constraint.upper,\n        list: constraint.items.length > 0 ? constraint.items : null\n      };\n    }) // @TODO @API rename this to constraints\n\n  };\n  return axios.post(`${api_url}/update-filter`, requestBody).then(response => {\n    const result = {};\n    Object.keys(response.data.plots).forEach(identifier => {\n      result[identifier] = parseFigure(response.data.plots[identifier].figure);\n    });\n    return result;\n  });\n}; // SUBGROUP DEFINE\n\n\nconst subgroupDefine = name => {\n  const requestBody = {\n    usertoken: token,\n    name: name\n  };\n  return axios.post(`${api_url}/subgroup-define`, requestBody).then(response => null);\n}; // SUBGROUP DELETE\n\n\nconst subgroupDelete = name => {\n  const requestBody = {\n    usertoken: token,\n    name: name\n  };\n  return axios.post(`${api_url}/subgroup-delete`, requestBody).then(response => null);\n}; // GET ALL ATTRIBUTES\n\n\nconst getAttributes = () => {\n  return axios.get(`${api_url}/get-all-attributes`);\n}; // TOKEN\n\n\nconst api_url = process.env.REACT_APP_API_URL;\n\nconst getToken = () => {\n  let token = localStorage.getStringItem('token');\n\n  if (!token) {\n    token = utilities.generateIdentifier();\n    localStorage.setStringItem('token', token);\n    sessionInit(); // @TODO do we need to wait until ready?\n  }\n\n  return token;\n};\n\ntoken = getToken();\nexport default {\n  sessionInit,\n  sessionReset,\n  controlsUpdate,\n  filterUpdate,\n  subgroupDefine,\n  subgroupDelete,\n  getAttributes\n};","map":{"version":3,"sources":["/Users/philippwegner/Desktop/UKB/git/PostIDSN-Viewer/src/services/Backend.ts"],"names":["localStorage","utilities","_axios","token","axios","create","withCredentials","parseFigure","input","figure","JSON","parse","data","map","fd","type","sessionInit","identifiers","requestBody","usertoken","plot_ids","post","api_url","then","response","sessionReset","Legend","Fit","Stack","Norm","controlsUpdate","controlsState","controls","plot","identifier","attX","attY","attC","Dt","dt","visit","followup","tolerance","bins","norm","stack","fit","legend","responseRaw","filterUpdate","filterState","concept","filter_table","constraints","constraint","attribute","lower","upper","list","items","length","result","Object","keys","plots","forEach","subgroupDefine","name","subgroupDelete","getAttributes","get","process","env","REACT_APP_API_URL","getToken","getStringItem","generateIdentifier","setStringItem"],"mappings":"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","sourcesContent":["import { Figure } from 'react-plotly.js';\nimport { FilterState, Concept } from '../containers/Filter';\nimport localStorage from '../services/LocalStorage';\nimport utilities from '../services/Utilities';\nimport { DiagramType, Visit, ControlsState } from './../containers/Controls';\nimport _axios from 'axios';\nimport { Datum } from 'plotly.js';\n\nlet token: string;\n\nconst axios = _axios.create({\n  withCredentials: true\n});\n\n// HELPER\n\nconst parseFigure = (input: string): Partial<Figure> => {\n  const figure = JSON.parse(input);\n  return {\n    ...figure,\n    data: figure.data?.map((fd: any) => {\n      return {\n        ...fd,\n        // use scatter plot WebGL variant to improve performance\n        type: fd.type === 'scatter' ? 'scattergl' : fd.type,\n      };\n    }),\n  };\n};\n\n// SESSION INIT\n\ninterface SessionInitRequest {\n  usertoken: string;\n  plot_ids: string[];\n}\n\ntype SessionInitResponse = any; // @TODO define SessionInitResponse\n\ntype SessionInitReturn = any; // @TODO define SessionInitReturn\n\nconst sessionInit = (\n  identifiers: string[] = []\n): Promise<SessionInitReturn> => {\n  const requestBody: SessionInitRequest = {\n    usertoken: token,\n    plot_ids: identifiers,\n  };\n  return axios\n    .post(`${api_url}/init`, requestBody)\n    .then((response: SessionInitResponse) => response.data);\n};\n\n// SESSION RESET\n\ninterface SessionResetRequest {\n  usertoken: string;\n}\n\ntype SessionResetResponse = any; // @TODO define SessionResetResponse\n\ntype SessionResetReturn = any; // @TODO define SessionResetReturn\n\nconst sessionReset = (): Promise<SessionResetReturn> => {\n  const requestBody: SessionResetRequest = {\n    usertoken: token,\n  };\n  return axios\n    .post(`${api_url}/reset-session`, requestBody)\n    .then((response: SessionResetResponse) => response.data);\n};\n\n// CONTROLS UPDATE\n\nexport enum Legend {\n  none = 'none',\n  legend = 'legend',\n  // @TODO add more legend values here\n}\n\nexport enum Fit {\n  none = 'none',\n  regression = 'regression',\n  // @TODO add more fit values here\n}\n\nenum Stack {\n  stack = 'stack',\n}\n\nenum Norm {\n  norm = 'norm',\n}\n\ninterface ControlsUpdateRequest {\n  usertoken: string;\n  controls: {\n    plot: string;\n    type: DiagramType;\n    attX: string;\n    attY: string;\n    attC: string;\n    Dt: number | null;\n    visit: Visit;\n    followup: number;\n    tolerance: number;\n    bins: number;\n    norm: Norm[];\n    stack: Stack[];\n    fit: Fit[];\n    legend: Legend[];\n  };\n}\n\ntype ControlsUpdateResponse = any; // @TODO define ControlsUpdateResponse\n\ntype ControlsUpdateReturn = Partial<Figure>;\n\nconst controlsUpdate = (\n  controlsState: ControlsState\n): Promise<ControlsUpdateReturn> => {\n  const requestBody: ControlsUpdateRequest = {\n    usertoken: token,\n    controls: {\n      plot: controlsState.identifier,\n      type: controlsState.type,\n      attX: controlsState.attX,\n      attY: controlsState.attY,\n      attC: controlsState.attC,\n      Dt: controlsState.dt,\n      visit: controlsState.visit,\n      followup: controlsState.followup,\n      tolerance: controlsState.tolerance,\n      bins: controlsState.bins,\n      norm: controlsState.norm ? [Norm.norm] : [],\n      stack: controlsState.stack ? [Stack.stack] : [],\n      fit: [controlsState.fit] ,\n      legend: [controlsState.legend] , \n    },\n  };\n  return axios\n    .post(`${api_url}/getdata`, requestBody)\n    .then((responseRaw: ControlsUpdateResponse) => {\n      return parseFigure(responseRaw.data.figure);\n    });\n};\n\n// FILTER UPDATE\n\ninterface FilterUpdateRequest {\n  usertoken: string;\n  concept: Concept;\n  filter_table: {\n    // @TODO @API rename this to constraints\n    attribute: string;\n    lower: number | null;\n    upper: number | null;\n    list: Datum[] | null;\n    // set: [], // @TODO @API is filter-edit.filter_table.set required?\n    // human_readable: string // @TODO @API is filter-edit.filter_table.human_readable required?\n  }[];\n}\n\ntype FilterUpdateResponse = any; // @TODO define FiltersUpdateResponse\n\nexport type FilterUpdateReturn = { [key: string]: Partial<Figure> };\n\nconst filterUpdate = (\n  filterState: FilterState\n): Promise<FilterUpdateReturn> => {\n  const requestBody: FilterUpdateRequest = {\n    usertoken: token,\n    concept: filterState.concept,\n    filter_table: filterState.constraints.map((constraint) => {\n      return {\n        attribute: constraint.attribute,\n        lower: constraint.lower,\n        upper: constraint.upper,\n        list: constraint.items.length > 0 ? constraint.items : null,\n      };\n    }), // @TODO @API rename this to constraints\n  };\n  return axios\n    .post(`${api_url}/update-filter`, requestBody)\n    .then((response) => {\n      const result: { [key: string]: Partial<Figure> } = {};\n      Object.keys(response.data.plots).forEach((identifier) => {\n        result[identifier] = parseFigure(\n          response.data.plots[identifier].figure\n        );\n      });\n      return result;\n    });\n};\n\n// SUBGROUP DEFINE\n\ninterface SubgroupDefineRequest {\n  usertoken: string;\n  name: string;\n}\n\ntype SubgroupDefineResponse = any; // @TODO define SubgroupDefineResponse\n\ntype SubgroupDefineReturn = null;\n\nconst subgroupDefine = (name: string): Promise<SubgroupDefineReturn> => {\n  const requestBody: SubgroupDefineRequest = {\n    usertoken: token,\n    name: name,\n  };\n  return axios\n    .post(`${api_url}/subgroup-define`, requestBody)\n    .then((response: SubgroupDefineResponse) => null);\n};\n\n// SUBGROUP DELETE\n\ninterface SubgroupDeeleteRequest {\n  usertoken: string;\n  name: string;\n}\n\nconst subgroupDelete = (name: string): Promise<any> => {\n  const requestBody: SubgroupDefineRequest = {\n    usertoken: token,\n    name: name,\n  };\n  return axios\n    .post(`${api_url}/subgroup-delete`, requestBody)\n    .then((response: any) => null);\n};\n\n// GET ALL ATTRIBUTES\n\nconst getAttributes = (): Promise<any> =>{\n  return axios.get(`${api_url}/get-all-attributes`);\n}\n\n\n// TOKEN\n\nconst api_url = process.env.REACT_APP_API_URL;\n\nconst getToken = () => {\n  let token = localStorage.getStringItem('token');\n  if (!token) {\n    token = utilities.generateIdentifier();\n    localStorage.setStringItem('token', token);\n    sessionInit(); // @TODO do we need to wait until ready?\n  }\n  return token;\n};\n\ntoken = getToken();\n\nexport default {\n  sessionInit,\n  sessionReset,\n  controlsUpdate,\n  filterUpdate,\n  subgroupDefine,\n  subgroupDelete,\n  getAttributes\n};\n"]},"metadata":{},"sourceType":"module"}